# Research: Сервис тестирования алгоритма генерации учебных треков

**Feature**: 001-algo-testing-mvp | **Date**: 2026-02-12

## 1. Взаимодействие Backend ↔ ML-сервис

### Decision
Backend вызывает ML-сервис синхронно через HTTP (внутренняя Docker-сеть). ML-сервис предоставляет единый эндпоинт `/pipeline/run` для запуска полного pipeline B1-B8 и эндпоинт `/pipeline/run` с WebSocket для стриминга прогресса.

### Rationale
- Простота: один вызов — один результат.
- Прогресс: WebSocket позволяет frontend показывать текущий шаг (B1...B8).
- Backend не хранит промежуточные состояния pipeline — это ответственность ML-сервиса (в памяти сессии, согласно FR-021).

### Alternatives considered
- **gRPC**: избыточен для 2 сервисов, добавляет proto-зависимость. Отклонён.
- **Message queue (Redis/RabbitMQ)**: добавляет 5-й контейнер, противоречит минимализму MVP. Отклонён. Может быть рассмотрен при масштабировании пакетной генерации.

---

## 2. Пакетная генерация (FR-014): стратегия параллелизма

### Decision
Пакетная генерация N версий (1–100) выполняется **последовательно** в ML-сервисе. Backend инициирует batch-запрос, ML-сервис итеративно запускает pipeline B1-B8 N раз. Прогресс отдаётся через Server-Sent Events (SSE).

### Rationale
- DeepSeek API имеет rate limits — параллельные запросы могут привести к 429 ошибкам.
- Последовательная генерация проще в реализации и отладке.
- При ошибке на i-м запуске уже готовые версии сохраняются (FR: «частичный отчёт»).
- SSE вместо WebSocket — проще для однонаправленного потока прогресса.

### Alternatives considered
- **Параллельная генерация (asyncio.gather)**: рискованно из-за rate limits DeepSeek; сложнее обрабатывать частичные сбои. Отклонено для MVP.
- **Фоновые задачи (Celery/ARQ)**: добавляет Redis + worker, избыточно для однопользовательского сервиса. Отклонено.

---

## 3. Хранение данных: PostgreSQL-схема

### Decision
Три основные таблицы: `student_profiles`, `personalized_tracks`, `qa_reports`. `PersonalizedTrack` хранит полную JSON-структуру в JSONB-колонке (вся иерархия: компетенции, ЗУН, учебные единицы, расписание). Реляционная нормализация вложенных структур не выполняется.

### Rationale
- Структура `PersonalizedTrack` глубоко вложенная (~20 типов, см. phase_b.md). Нормализация создаст 15+ таблиц — избыточно для MVP.
- JSONB в PostgreSQL поддерживает индексы и запросы по вложенным полям.
- Основные сценарии: «сохранить целиком» и «загрузить целиком» — JSONB идеально подходит.
- При необходимости аналитики по отдельным полям — GIN-индексы на JSONB.

### Alternatives considered
- **Полная нормализация**: 15+ таблиц с FK. Огромный overhead для MVP, сложные миграции. Отклонено.
- **MongoDB**: нативный JSON-документ, но добавляет новую СУБД вне конституции (PostgreSQL зафиксирован). Отклонено.
- **Файловое хранилище (JSON на диске)**: нет транзакций, нет индексов, сложнее связывать с профилями. Отклонено.

---

## 4. Расчёт CDV (FR-017): алгоритм сравнения

### Decision
CDV считается на стороне ML-сервиса после завершения пакетной генерации. Алгоритм:

1. **Структура тем (вес 0.4)**: Jaccard similarity по множествам нормализованных названий тем двух версий. Нормализация: lowercase, удаление стоп-слов, stemming.
2. **Содержание подтем (вес 0.3)**: Для каждой общей темы — Jaccard similarity по подтемам.
3. **Состав учебных действий (вес 0.3)**: Для каждой общей подтемы — Jaccard similarity по учебным действиям.

```
CDV(v1, v2) = 1 - (0.4 * topic_sim + 0.3 * subtopic_sim + 0.3 * activity_sim)
```

CDV = 0% → идентичные; CDV = 100% → полностью различные.

### Rationale
- Jaccard distance — простой, интерпретируемый, не требует ML-моделей.
- Нормализация имён решает проблему стилистических различий (LLM может формулировать одну тему по-разному).
- Веса (0.4/0.3/0.3) заданы в ТЗ.

### Alternatives considered
- **Cosine similarity на embeddings**: точнее, но требует модели эмбеддингов (дополнительная зависимость). Может быть добавлен позже.
- **Tree edit distance**: учитывает структуру, но вычислительно дороже и сложнее интерпретировать. Отклонено для MVP.

---

## 5. DeepSeek client: retry и error handling

### Decision
ML-сервис использует `httpx.AsyncClient` с custom retry-wrapper:
- Retry: до 3 попыток с exponential backoff (1s, 4s, 16s).
- На 429 (rate limit): respect `Retry-After` header.
- На 5xx / timeout: retry.
- На невалидный JSON в ответе LLM: retry с тем же промптом (до 2 раз).
- Structured output: каждый промпт требует JSON-ответ; парсинг через Pydantic-модель.

### Rationale
- DeepSeek API может быть нестабилен; retry — обязательное требование конституции (Принцип V: graceful degradation).
- Structured output через Pydantic гарантирует валидность промежуточных результатов B1-B8.

### Alternatives considered
- **LangChain / LlamaIndex**: добавляет тяжёлую зависимость, маскирует логику retry. Отклонено.
- **OpenAI Python SDK с custom base_url**: возможно, но httpx даёт полный контроль. Предпочтён httpx.

---

## 6. Frontend: отображение древовидной структуры (FR-007)

### Decision
Используется кастомный React-компонент `TreeView` на основе Tailwind CSS с раскрывающимися узлами. Уровни дерева:
```
Компетенции → ЗУН → Учебные единицы → Уровни → Недели → Дни → Учебные действия
```

### Rationale
- Структура `PersonalizedTrack` специфична — стандартные tree-библиотеки не подходят «из коробки».
- Tailwind CSS (конституция) — достаточно для стилизации.
- Простой рекурсивный компонент с `useState` для раскрытия/свёртки узлов.

### Alternatives considered
- **react-arborist / react-treeview**: добавляет зависимость, может не подходить для специфичной структуры данных. Отклонено.
- **Tabular view**: менее наглядно для иерархических данных. Отклонено.

---

## 7. Валидация JSON-профиля (FR-002): схема

### Decision
Валидация входного JSON выполняется на стороне backend через Pydantic v2 модель `StudentProfileInput`. Модель отражает структуру `StudentProfile` из `docs/phase_a.md` с учётом уровней значимости:
- CRITICAL-поля: обязательные (ValidationError при отсутствии).
- IMPORTANT-поля: опциональные с предупреждением.
- OPTIONAL-поля: опциональные без предупреждения.

Ответ валидации: `{ valid: bool, errors: [], warnings: [] }`.

### Rationale
- Pydantic v2 — нативная часть FastAPI, нулевой overhead.
- Разделение на errors/warnings позволяет реализовать FR-004 (предупреждения при отсутствии IMPORTANT-полей).

### Alternatives considered
- **JSON Schema + jsonschema lib**: дополнительная зависимость, менее гибкая для warnings vs errors. Отклонено.
- **Валидация на frontend**: не обеспечивает защиту API. Валидация на backend обязательна; frontend может дублировать для UX.

---

## 8. Экспорт результатов (FR-011–FR-013)

### Decision
Экспорт реализуется через backend API:
- `GET /api/tracks/{id}/export` → скачивание `track_[topic]_[timestamp].json`.
- `GET /api/qa-reports/{id}/export` → скачивание QA-отчёта JSON.
- `GET /api/qa-reports/{id}/export-all` → скачивание ZIP-архива со всеми версиями + отчётом.

Backend формирует файл в памяти и отдаёт `StreamingResponse` с `Content-Disposition: attachment`.

### Rationale
- Серверный экспорт — единая точка формирования файла.
- StreamingResponse позволяет отдавать большие файлы без загрузки в память целиком.
- ZIP для пакетного экспорта — стандартный формат.

### Alternatives considered
- **Frontend-side export (Blob API)**: работает только для данных, уже загруженных в браузер. При 100 треках — слишком много данных. Отклонено.